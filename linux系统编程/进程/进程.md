# 进程
进程，占用系统资源，如：物理内存，CPU，终端等。
## PCB进程控制块
每个进程在内核中都有一个进程控制快来维护进程相关的信息，Linux内核的进程控制快是task_struct结构体。\
- 进程id。每个进程有唯一的id，在c中用pid_t表示，其实就是一个非负整数。
- 进程的状态，有就绪，运行，挂起，停止等状态。
- 进程切换时需要保存和恢复的一些CPU寄存器。
- 描述虚拟地址空间的信息。
- 描述控制终端的信息。
- 当前的工作目录。
- umask掩码。
- 文件描述符表，包含很多指向file结构体的指针。
- 和信号相关的信息。
- 用户id和组id。
- 会话和会话组。

## fork函数
pid_t fork(void);\
返回值：调用成功：父进程返回子进程的PID，子进程返回0；调用失败返回-1；\
父进程调用fork函数创建一个子进程，子进程的用户区和父进程的用户区完全一样，但是内核区不完全一样：如二者的pid不一致。\
父子进程的执行逻辑：\
父进程执行pid>0的逻辑，子进程执行pid=0的逻辑。\
父子进程不共享全局变量。写时复制，读时共享
## exec函数族
 如果需要在一个进程内部执行系统命令或者应用程序，优先应使用如下方式：\
先fork（），然后在子进程里面执行execl拉起可执行程序或者命令。\
int execl( pat h, "ls", "-l", NULL );调用execl函数之后，子进程的代码段会被ls命令的代码段替换，注意**子进程的地址空间没有变化，子进程的pid没有变化。**\
成功不反回，失败之后回执行execl后面的代码，可以用perror打印错误原因。\
int execlp( const char* file, const char *arg, ../NULL);\
file:z执行命令的名字，根据PATH环境变量来搜索。\
execl一般用于执行用户自定义的应用程序。\
execlp一般用于执行系统命令。
## 孤儿进程
当一个进程退出后，进程能够回收自己的用户区的资源，但是不能回收内核空间的PCB，必须由他的父进程调用wait或者waitpid函数完成对子进程的回收。\
若子进程的父进程已经死掉，而子进程还存活，这个进程就成了孤儿进程。\
为了保证每个进程都有一个父进程，孤儿进程会被init进程给收养，当孤儿进程退出之后，资源会被init进程回收。
## 僵尸进程
子进程先退出后，父进程没有完成对子进程的资源回收，此时子进程就变成了僵尸进程。不能使用kill -9杀死僵尸进程，原因是因为僵尸进程是一个死掉的进程，\
应该使用杀死僵尸进程父进程的方法杀死僵尸进程，原因：杀死其父进程，可以让init领养僵尸进程，最终有init进程回收僵尸进程.\
##
进程回收函数wait:\
pid_t wait( int *stauts );\
函数作用阻塞并等待子进程退出，回收子进程残留资源，获取子进程结束状态。\
成功返回子进程的ID，失败则返回-1。\
stauts:子进程的退出状态
- WIFEFXITED( status )
- WEXITSTATUS( stauts )
- WTERMSIG( status )

pid_t waitpid( pid_t pid, int* status, int options );\
作用同wait，参数pid：
- pid=-1 等待任一子进程，与wait等效。
- pid > 0 等待其进程ID与pid相同的子进程。
- pid = 0,等待进程组ID与目前进程相同的任何子进程。

options:默认为阻塞状态，若设置为WNOHANG,函数不阻塞。\
f返回值:
- pid>0: 返回掉回收的子进程ID；
- -1： 无子进程。
- =0：参数3为WNOHANG，且子进程正在运行.

调用一次waitpid或者wait函数只能回收一个子进程。\
父子进程可以共享文件。

## 进程间通信
进程间通信必须通过内核。\
常用的通信方式: 文件，管道，信号，共享内存，消息队列，套接字，命名管道。
### 管道
管道是最基本的IPC机制，也称为匿名管道，应用于有血缘关系的进程间通信，完成数据传递。\
- 管道的本质是一块内核缓冲区。
- 由两个文件描述符引用，一个表示读端，一个表示写端。
- 规定数据从管道的写端流入管道，从独断流出。
- 当两个进程都终结时，管道也会自动小时。
- 管道的读端和写端默认都是阻塞的。
- 数据一旦被取走，便不在管道中存在，不可反复读取。
- 管道的读写两端是阻塞的。
- 管道大小默认为4K，但是会根据实际情况做适当调整。
#### 管道函数
int pipe( int fd[2] );// 若函数掉调用成功，fd[0]存放管道的读，fd[1]存放管道的写端，成功返回0，失败返回-1.\
管道的两端都是堵塞的。\
父进程：\
1.创建管道\
2.创建子进程。\
3.在父进程中关闭读端fd[0];\
4.在子进程中关闭写端fd[1]\
5.在父进程中将标准输出重定向到管道的写端。\
6.在子进程中将标准输入重定向到管道的读端。\
7.在父进程中调用execl函数执行ps aux命令。\
8.在子进程中调用execl函数执行grep bash 命令。\
9.在父进程中回收子进程wait函数。\
若是管道的读端关闭，那么管道会直接破裂，进程终止。读端没有关闭，但是缓冲区写满了，写端会阻塞。

###FIFO
FIFO常被称为命名管道，通过FIFO，能够用于不同进程间的通信。\
FIFO是LINUX基础文件类型的一种，文件类型为p，但是FIFO文件在磁盘上没有数据块，文件大小为0，仅用来表示内核中的一条通道.\
创建管道:\
命令: mkfifo;函数 int mkfifo(const char* filename, mode_t mode)\
fifo完成两个进程间通信，\
进程A：\
1 创建一个fifo文件。\
2.oepn fifo文件，获得一个文件描述符fd。\
3.write(fd, "xxx")写fifo文件.\
4.关闭fifo文件，close(fd);\
进程B：\
1、打开fifo文件，获得文件描述符。\
2、读fifo文件。\
3、close。\
int access(char* pathname, mode_t mode);// 能够判断文件是否存在以及文件的权限。\
### 内存映射区
void *mmap(void*addr, size_t length, int prot, int flags, int fd, int fd, off_t offset);\
成功返回创建的映射区收地址；\
失败返回：MAP_FAILD宏。\
参数：
- addr: 指定映射的起始地址，通常为NULL。
- length：映射到内存的文件长度。
- prot：映射区的保护方式
-        读：PROT_READ
-        写：PROT_WRITE
-        读和写： PROT_READ｜PROT_WRITE。
- flags：映射去的特性
-      MAP_SHARED：写入映射去的数据会写回文件，可以对文件修改。
-      MAP_PRIVATE：对映射区的不允许写，对映射区的修改，不会产生影响
- fd:打开的文件描述符。
- offset：从文件的那个位置进行映射，一般传0,必须是4k的整数倍。

munmap：释放,传入地址一定是mmap的返回地址。\




















