# 进程
进程，占用系统资源，如：物理内存，CPU，终端等。
## PCB进程控制块
每个进程在内核中都有一个进程控制快来维护进程相关的信息，Linux内核的进程控制快是task_struct结构体。\
- 进程id。每个进程有唯一的id，在c中用pid_t表示，其实就是一个非负整数。
- 进程的状态，有就绪，运行，挂起，停止等状态。
- 进程切换时需要保存和恢复的一些CPU寄存器。
- 描述虚拟地址空间的信息。
- 描述控制终端的信息。
- 当前的工作目录。
- umask掩码。
- 文件描述符表，包含很多指向file结构体的指针。
- 和信号相关的信息。
- 用户id和组id。
- 会话和会话组。

## fork函数
pid_t fork(void);\
返回值：调用成功：父进程返回子进程的PID，子进程返回0；调用失败返回-1；\
父进程调用fork函数创建一个子进程，子进程的用户区和父进程的用户区完全一样，但是内核区不完全一样：如二者的pid不一致。\
父子进程的执行逻辑：\
父进程执行pid>0的逻辑，子进程执行pid=0的逻辑。\
父子进程不共享全局变量。写时复制，读时共享
## exec函数族
 如果需要在一个进程内部执行系统命令或者应用程序，优先应使用如下方式：\
先fork（），然后在子进程里面执行execl拉起可执行程序或者命令。\
int execl( pat h, "ls", "-l", NULL );调用execl函数之后，子进程的代码段会被ls命令的代码段替换，注意**子进程的地址空间没有变化，子进程的pid没有变化。**\
成功不反回，失败之后回执行execl后面的代码，可以用perror打印错误原因。\
int execlp( const char* file, const char *arg, ../NULL);\
file:z执行命令的名字，根据PATH环境变量来搜索。\
execl一般用于执行用户自定义的应用程序。\
execlp一般用于执行系统命令。
## 孤儿进程
当一个进程退出后，进程能够回收自己的用户区的资源，但是不能回收内核空间的PCB，必须由他的父进程调用wait或者waitpid函数完成对子进程的回收。\
若子进程的父进程已经死掉，而子进程还存活，这个进程就成了孤儿进程。\
为了保证每个进程都有一个父进程，孤儿进程会被init进程给收养，当孤儿进程退出之后，资源会被init进程回收。
## 僵尸进程
子进程先退出后，父进程没有完成对子进程的资源回收，此时子进程就变成了僵尸进程。不能使用kill -9杀死僵尸进程，原因是因为僵尸进程是一个死掉的进程，\
应该使用杀死僵尸进程父进程的方法杀死僵尸进程，原因：杀死其父进程，可以让init领养僵尸进程，最终有init进程回收僵尸进程.\
##
进程回收函数wait:\
pid_t wait( int *stauts );\
函数作用阻塞并等待子进程退出，回收子进程残留资源，获取子进程结束状态。\
成功返回子进程的ID，失败则返回-1。\
stauts:子进程的退出状态
- WIFEFXITED( status )
- WEXITSTATUS( stauts )
- WTERMSIG( status )

pid_t waitpid( pid_t pid, int* status, int options );\
作用同wait，参数pid：
- pid=-1 等待任一子进程，与wait等效。
- pid > 0 等待其进程ID与pid相同的子进程。
- pid = 0,等待进程组ID与目前进程相同的任何子进程。

options:默认为阻塞状态，若设置为WNOHANG,函数不阻塞。\
f返回值:
- pid>0: 返回掉回收的子进程ID；
- -1： 无子进程。
- =0：参数3为WNOHANG，且子进程正在运行.

调用一次waitpid或者wait函数只能回收一个子进程。\
























